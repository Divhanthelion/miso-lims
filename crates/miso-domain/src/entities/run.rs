//! Run entity - a sequencing run on an instrument.
//!
//! A Run represents the execution of sequencing on a specific instrument,
//! linking pools to the generated data.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

use super::EntityId;

/// The status of a sequencing run.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum RunStatus {
    /// Run is being set up
    #[default]
    Unknown,
    /// Run is in progress
    Running,
    /// Run completed successfully
    Completed,
    /// Run failed
    Failed,
    /// Run was stopped/aborted
    Stopped,
    /// QC is being performed on the run
    QcInProgress,
    /// QC completed successfully
    QcPassed,
    /// QC failed
    QcFailed,
}

impl RunStatus {
    /// Returns true if this run is still in progress.
    pub fn is_active(&self) -> bool {
        matches!(self, Self::Running | Self::QcInProgress)
    }

    /// Returns true if this run is complete (regardless of pass/fail).
    pub fn is_terminal(&self) -> bool {
        matches!(
            self,
            Self::Completed | Self::Failed | Self::Stopped | Self::QcPassed | Self::QcFailed
        )
    }

    /// Returns true if this run was successful.
    pub fn is_successful(&self) -> bool {
        matches!(self, Self::Completed | Self::QcPassed)
    }
}

impl std::fmt::Display for RunStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Unknown => write!(f, "Unknown"),
            Self::Running => write!(f, "Running"),
            Self::Completed => write!(f, "Completed"),
            Self::Failed => write!(f, "Failed"),
            Self::Stopped => write!(f, "Stopped"),
            Self::QcInProgress => write!(f, "QC In Progress"),
            Self::QcPassed => write!(f, "QC Passed"),
            Self::QcFailed => write!(f, "QC Failed"),
        }
    }
}

/// A partition (lane/cell) of a sequencing run.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct RunPartition {
    /// Partition number (1-based, e.g., lane 1, lane 2)
    pub partition_number: u8,
    /// Pool loaded on this partition
    pub pool_id: Option<EntityId>,
    /// Loading concentration (pM)
    pub loading_concentration: Option<f64>,
    /// Cluster density (K/mmÂ²)
    pub cluster_density: Option<f64>,
    /// Percentage of clusters passing filter
    pub pass_filter_percent: Option<f64>,
    /// Q30 score (percentage of bases with Q >= 30)
    pub q30_percent: Option<f64>,
    /// Notes about this partition
    pub notes: Option<String>,
}

impl RunPartition {
    /// Creates a new partition.
    pub fn new(partition_number: u8) -> Self {
        Self {
            partition_number,
            pool_id: None,
            loading_concentration: None,
            cluster_density: None,
            pass_filter_percent: None,
            q30_percent: None,
            notes: None,
        }
    }

    /// Sets the pool for this partition.
    pub fn set_pool(&mut self, pool_id: EntityId, loading_concentration: f64) {
        self.pool_id = Some(pool_id);
        self.loading_concentration = Some(loading_concentration);
    }

    /// Updates QC metrics.
    pub fn set_metrics(
        &mut self,
        cluster_density: f64,
        pass_filter_percent: f64,
        q30_percent: f64,
    ) {
        self.cluster_density = Some(cluster_density);
        self.pass_filter_percent = Some(pass_filter_percent);
        self.q30_percent = Some(q30_percent);
    }
}

/// A sequencing run.
///
/// Runs are the execution of sequencing on a specific instrument,
/// generating data from the loaded pools.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Run {
    /// Unique identifier
    pub id: EntityId,
    /// Run name (often auto-generated by the instrument)
    pub name: String,
    /// Run alias (human-friendly name)
    pub alias: Option<String>,
    /// The sequencer this run was performed on
    pub sequencer_id: EntityId,
    /// The container (flow cell) used
    pub container_barcode: Option<String>,
    /// Current status
    pub status: RunStatus,
    /// The partitions (lanes/cells) of this run
    pub partitions: Vec<RunPartition>,
    /// Path to the run data on disk
    pub data_path: Option<String>,
    /// Path to the run output/analysis
    pub output_path: Option<String>,
    /// When the run started
    pub started_at: Option<DateTime<Utc>>,
    /// When the run completed
    pub completed_at: Option<DateTime<Utc>>,
    /// Number of read cycles (e.g., "2x150" for 150bp paired-end)
    pub read_length: Option<String>,
    /// Run description/notes
    pub description: Option<String>,
    /// Who created this record
    pub created_by: String,
    /// When this record was created
    pub created_at: DateTime<Utc>,
    /// When this record was last modified
    pub updated_at: DateTime<Utc>,
}

impl Run {
    /// Creates a new run.
    pub fn new(
        id: EntityId,
        name: String,
        sequencer_id: EntityId,
        num_partitions: u8,
        created_by: String,
    ) -> Self {
        let now = Utc::now();
        let partitions = (1..=num_partitions)
            .map(RunPartition::new)
            .collect();

        Self {
            id,
            name,
            alias: None,
            sequencer_id,
            container_barcode: None,
            status: RunStatus::Unknown,
            partitions,
            data_path: None,
            output_path: None,
            started_at: None,
            completed_at: None,
            read_length: None,
            description: None,
            created_by,
            created_at: now,
            updated_at: now,
        }
    }

    /// Sets the container (flow cell) barcode.
    pub fn set_container(&mut self, barcode: String) {
        self.container_barcode = Some(barcode);
        self.updated_at = Utc::now();
    }

    /// Starts the run.
    pub fn start(&mut self) {
        self.status = RunStatus::Running;
        self.started_at = Some(Utc::now());
        self.updated_at = Utc::now();
    }

    /// Completes the run.
    pub fn complete(&mut self) {
        self.status = RunStatus::Completed;
        self.completed_at = Some(Utc::now());
        self.updated_at = Utc::now();
    }

    /// Fails the run.
    pub fn fail(&mut self) {
        self.status = RunStatus::Failed;
        self.completed_at = Some(Utc::now());
        self.updated_at = Utc::now();
    }

    /// Gets a partition by number.
    pub fn get_partition(&self, number: u8) -> Option<&RunPartition> {
        self.partitions.iter().find(|p| p.partition_number == number)
    }

    /// Gets a mutable partition by number.
    pub fn get_partition_mut(&mut self, number: u8) -> Option<&mut RunPartition> {
        self.partitions.iter_mut().find(|p| p.partition_number == number)
    }

    /// Returns the number of partitions.
    pub fn num_partitions(&self) -> usize {
        self.partitions.len()
    }

    /// Returns all pool IDs in this run.
    pub fn pool_ids(&self) -> Vec<EntityId> {
        self.partitions
            .iter()
            .filter_map(|p| p.pool_id)
            .collect()
    }

    /// Calculates the average Q30 across all partitions.
    pub fn average_q30(&self) -> Option<f64> {
        let q30s: Vec<f64> = self
            .partitions
            .iter()
            .filter_map(|p| p.q30_percent)
            .collect();

        if q30s.is_empty() {
            None
        } else {
            Some(q30s.iter().sum::<f64>() / q30s.len() as f64)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_run_creation() {
        let run = Run::new(1, "RUN001".to_string(), 1, 8, "admin".to_string());
        assert_eq!(run.num_partitions(), 8);
        assert_eq!(run.status, RunStatus::Unknown);
    }

    #[test]
    fn test_run_lifecycle() {
        let mut run = Run::new(1, "RUN001".to_string(), 1, 4, "admin".to_string());

        assert!(!run.status.is_active());

        run.start();
        assert_eq!(run.status, RunStatus::Running);
        assert!(run.status.is_active());
        assert!(run.started_at.is_some());

        run.complete();
        assert_eq!(run.status, RunStatus::Completed);
        assert!(run.status.is_terminal());
        assert!(run.status.is_successful());
        assert!(run.completed_at.is_some());
    }

    #[test]
    fn test_partition_metrics() {
        let mut run = Run::new(1, "RUN001".to_string(), 1, 4, "admin".to_string());

        let partition = run.get_partition_mut(1).unwrap();
        partition.set_pool(1, 250.0);
        partition.set_metrics(1200.0, 95.0, 89.5);

        let partition = run.get_partition(1).unwrap();
        assert_eq!(partition.pool_id, Some(1));
        assert_eq!(partition.q30_percent, Some(89.5));
    }

    #[test]
    fn test_average_q30() {
        let mut run = Run::new(1, "RUN001".to_string(), 1, 2, "admin".to_string());

        // No metrics yet
        assert!(run.average_q30().is_none());

        // Add metrics
        run.get_partition_mut(1).unwrap().set_metrics(1200.0, 95.0, 90.0);
        run.get_partition_mut(2).unwrap().set_metrics(1100.0, 94.0, 88.0);

        let avg = run.average_q30().unwrap();
        assert!((avg - 89.0).abs() < 0.01);
    }
}

