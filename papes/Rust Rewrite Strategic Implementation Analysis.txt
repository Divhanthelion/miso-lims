Strategic Technical Blueprint: Modernization and Re-platforming of the MISO Laboratory Information Management System to Rust
Executive Summary
The Managing Information for Sequencing Operations (MISO) system stands as a critical infrastructure pillar for the Ontario Institute for Cancer Research (OICR) and the Earlham Institute. For over a decade, it has orchestrated the complex, high-stakes workflows of Next-Generation Sequencing (NGS), managing the lineage of biological samples from patient intake through extraction, library preparation, and final sequencing on platforms ranging from Illumina to Oxford Nanopore.1 However, the operational reality of modern genomics is characterized by a hyper-exponential growth in data throughput and workflow complexity. The legacy architecture—a tiered Java monolith built upon the Spring Framework and Hibernate—has served its purpose but now faces fundamental ceilings in scalability, resource determinism, and maintainability.1
This report presents a comprehensive, expert-level analysis and implementation blueprint for re-platforming MISO to a Rust-based architecture. This transition is not merely a language swap; it is a strategic architectural realignment designed to secure the facility's operational capability for the next decade. By leveraging Rust’s affine type system, we can encode biological constraints directly into the compiler, making invalid laboratory states (such as pooling an unextracted sample) mathematically unrepresentable.1 By moving from the Java Virtual Machine (JVM) to a native binary model using the Tokio asynchronous runtime, we eliminate the non-deterministic garbage collection pauses that currently threaten the integrity of high-speed hardware integrations, such as the VisionMate barcode scanners.1
The proposed architecture adopts a Modular Monolith structure utilizing Hexagonal Architecture (Ports and Adapters). This ensures that the core domain logic—the "science" of the LIMS—remains hermetically sealed from the fluctuating standards of web frameworks and database dialects.1 The technology stack selection—Axum for the API, SeaORM for persistence, Leptos for a reactive WASM frontend, and Tokio for hardware I/O—represents the cutting edge of the Rust ecosystem, specifically curated to address the distinct pain points of the legacy system: startup time, memory footprint, N+1 query performance, and UI latency.1
This document serves as the definitive technical reference for the engineering team charged with this transformation. It synthesizes deep architectural analysis with granular implementation details, ranging from the topology of the Cargo workspace to the bit-wise optimization of DNA barcode comparisons.
________________
1. The Operational Context: The Imperative for Deterministic Systems
To understand the necessity of this rewrite, one must first appreciate the specific operational stresses placed on a LIMS in a high-throughput sequencing facility. Unlike standard enterprise inventory systems, a LIMS does not merely track static assets; it manages a dynamic biological metamorphosis.
1.1 The Velocity of Genomic Data and Hardware Integration
The sequencing centers at OICR and Earlham are not static warehouses. They are high-velocity manufacturing environments where the "product" is data derived from biological matter. The facility integrates a diverse array of hardware:
* Liquid Handling Robots: Automated pipetting systems that prepare hundreds of samples simultaneously.
* Sequencers: Instruments like the Illumina NovaSeq or Oxford Nanopore PromethION that generate terabytes of data per run.1
* Peripheral Automation: Barcode scanners (Thermo Scientific VisionMate) and label printers (Zebra) that act as the primary interface between the technician and the digital record.1
In the legacy Java architecture, these hardware integrations are mediated by the JVM. While the JVM is highly optimized for sustained throughput (e.g., serving web requests), it struggles with latency determinism. A "stop-the-world" Garbage Collection (GC) event, triggered by the allocation churn of a large Hibernate session, can pause the application for hundreds of milliseconds. If this pause occurs while a technician is rapidly scanning a 96-well rack, the serial buffer from the scanner may overflow, or the UI may fail to acknowledge the scan, leading to "ghost samples" and user frustration. The Rust architecture, with its ownership-based memory management and lack of a runtime GC, guarantees consistent, low-latency responses, ensuring that the digital record moves at the speed of the physical lab.1
1.2 The "Make Invalid States Unrepresentable" Philosophy
Biological workflows are strictly linear and state-dependent. A sample must be Received before it is Extracted. It must be Extracted before it is Library Prepped. It must be Library Prepped before it is Pooled.
In the legacy system, these states are typically managed via "Stringly Typed" logic—runtime checks against string enumerations stored in the database. This approach is fragile. A developer might accidentally write code that allows a Received sample to be added to a Pool, and the error would only be caught at runtime, possibly resulting in the waste of expensive reagents.
Rust offers a paradigm shift via the Typestate Pattern. We can define distinct types for each state (Sample<Received>, Sample<Extracted>). The function signature for pooling can be defined to only accept Sample<LibraryPrepped>. In this model, passing a raw sample to the pooling function results in a compilation error. The code literally cannot be built if it violates the biological workflow. This moves the burden of validation from the runtime user to the compile-time architect, significantly reducing the surface area for logic bugs.3
________________
2. Deconstructing the Legacy Estate: Anatomy of the Monolith
A successful rewrite requires a rigorous understanding of the artifact being replaced. The current MISO system is a semantic map of the laboratory's operations, encoded in the enterprise Java standards of the mid-2010s.
2.1 The Legacy Technology Stack: Strengths and Liabilities
The existing repository reveals a classic Tiered Java Monolith structure.1
Table 1: Legacy Stack Analysis


Component
	Legacy Technology
	Role & Characteristics
	Operational Liability
	Framework
	Spring Framework
	Dependency Injection (IOC) and Web MVC.
	Runtime Reflection: Spring relies heavily on scanning the classpath at startup to wire dependencies (@Autowired). This results in slow startup times and runtime failures if beans are missing. It obscures the dependency graph, making the system hard to reason about.1
	Persistence
	Hibernate (JPA) + MySQL
	Object-Relational Mapping.
	The N+1 Problem: Hibernate’s "Lazy Loading" (e.g., sample.getLibraries()) often triggers hidden SQL queries inside loops. In a LIMS view showing a freezer with 10 shelves x 10 racks x 96 tubes, this can trigger thousands of queries, paralyzing the UI.1
	Frontend
	JSP, Tiles, jQuery
	Server-Side Rendering (SSR).
	Tight Coupling: The UI logic is entangled with the backend. Interactivity (like drag-and-drop plate maps) requires "hacking" jQuery on top of static HTML, leading to brittle, unmaintainable frontend code.1
	Build
	Maven
	Dependency Management.
	XML Verbosity: While stable, the verbose pom.xml configuration manages a complex web of transitive dependencies that can be difficult to audit for security vulnerabilities.1
	2.2 The Data Model: Polymorphism and Hierarchy
The MISO data model is the heart of the system. It supports a deep hierarchy of biological entities, notably the distinction between "Plain" and "Detailed" samples.1
* Plain Sample Mode: Used for high-throughput core facilities. The lineage is flat: Sample -> Library -> Pool.
* Detailed Sample Mode: Used for clinical research. The lineage is deep: Identity -> Tissue -> Stock -> Aliquot -> Library.
In the legacy database, this polymorphism is likely handled via a Joined Inheritance strategy (e.g., a Sample table joined to a DetailedSample table). While JPA handles this transparently, it often results in complex, slow SQL JOIN operations. Rust's SeaORM does not support inheritance natively, requiring a fundamental rethinking of how this data is modeled using Composition and Enums to achieve the same expressive power without the performance penalty.5
2.3 Hardware Integration Constraints
The legacy visionmate-client and printer integrations rely on Java's java.net.Socket. These are typically blocking I/O operations. Each connected device consumes a thread. If a scanner hangs or the network is flaky, the thread blocks, potentially exhausting the thread pool and making the server unresponsive. Modernizing this to a non-blocking, asynchronous model is a critical requirement for scaling the system to support more devices.1
________________
3. Architectural Blueprint: The Rust Modular Monolith
To modernize MISO, we will adopt a Modular Monolith architecture utilizing Hexagonal Architecture (also known as Ports and Adapters). This approach strikes a strategic balance: it allows for the simplicity of a single deployment unit (monolith) while enforcing the strict boundaries and decoupling usually associated with microservices.
3.1 The Cargo Workspace Topology
The Rust implementation will be organized as a Cargo Workspace. This physical separation of code into "Crates" enforces logical separation. Code in the Domain layer cannot import code from the Web layer, preventing the "spaghetti code" entropy that plagues legacy systems.
Table 2: MISO Rust Workspace Crate Graph
Crate Name
	Architectural Layer
	Primary Responsibilities
	Strategic Dependencies
	miso-domain
	Core (The Hexagon)
	Defines the "Platonic Ideals" of the system: Entities (Sample, Run), Value Objects (Barcode, Concentration), Domain Errors, and Repository Traits. Contains pure business logic.
	None. Strictly forbids sqlx, axum, or tokio. Depends only on std and thiserror.
	miso-application
	Application Logic
	Implements Use Cases (ReceiveSample, PoolLibraries) that orchestrate domain objects. Defines Service Structs and Data Transfer Objects (DTOs).
	miso-domain, tracing, anyhow.
	miso-infrastructure
	Adapter (Right Side)
	Provides concrete implementations of Repository Traits using SeaORM. Implements Hardware Clients (VisionMate) using Tokio. Implements 3rd-party integrations (LDAP).
	miso-domain, sea-orm, tokio, reqwest, ldap3.
	miso-api
	Port (Left Side)
	The entry point for external interaction. Configures the Axum web server, defines HTTP Routes, handles Auth Middleware, and maps HTTP JSON to DTOs.
	miso-application, axum, tower, serde.
	miso-frontend
	User Interface
	A Leptos WASM application responsible for the client-side experience. Components for Plate Maps, Forms, and Dashboards.
	leptos, wasm-bindgen.
	miso-migration
	Tooling
	Manages database schema evolution. Contains SQL scripts and SeaORM migration logic to ensure the DB schema matches the code.
	sea-orm-migration.
	3.2 Strategic Rationale: The miso-domain Purity
The defining characteristic of this architecture is the purity of the miso-domain crate. By enforcing a rule that the domain layer cannot depend on the database (sqlx) or the web framework (axum), we achieve:
1. Testability: We can write unit tests for complex biological logic (e.g., index collision detection) that run in milliseconds because they do not require spinning up a database container or mocking an HTTP server.1
2. Longevity: Frameworks change. If, in five years, Axum is superseded by a newer web framework, we can replace the miso-api crate without touching a single line of the core scientific logic in miso-domain.1
3.3 Dependency Injection: Compile-Time vs. Runtime
Spring's Dependency Injection is dynamic; it wires components at runtime. Rust does not have a runtime reflection capabilities of Java. Instead, we will use Compile-Time Dependency Injection via Traits and Constructor Injection.1
The Implementation Pattern:
The miso-application crate defines a need:


Rust




// miso-domain/src/repositories.rs
#[async_trait]
pub trait SampleRepository: Send + Sync {
   async fn save(&self, sample: &Sample) -> Result<SampleId, DomainError>;
}

The miso-infrastructure crate provides the solution:


Rust




// miso-infrastructure/src/persistence.rs
pub struct SeaOrmSampleRepository { db: DatabaseConnection }
impl SampleRepository for SeaOrmSampleRepository {... }

The wiring happens explicitly in main.rs:


Rust




// main.rs
let db = Database::connect(...).await?;
let repo = SeaOrmSampleRepository::new(db);
let service = AccessionService::new(repo); // Compiler verifies repo implements SampleRepository

This approach eliminates "startup crashes" caused by missing beans, replacing them with compile-time errors that prevent the bad code from ever shipping.1
________________
4. The Data Layer: Transitioning to SeaORM
The migration from Hibernate to SeaORM represents the most significant shift in the backend development model. SeaORM is an async-native ORM that fits perfectly with the Tokio ecosystem, but it requires a shift from "Implicit Magic" to "Explicit Control."
4.1 Schema-First Development
Unlike Hibernate, which often encourages generating the database schema from Java classes (Code-First), SeaORM supports a Schema-First workflow. Since MISO has a mature, production MySQL database, we will leverage sea-orm-cli to reverse-engineer the existing schema.
* Action: Run sea-orm-cli generate entity -u mysql://... against the production DB.
* Result: This auto-generates Rust structs for all tables (Sample, Run, Pool), ensuring 100% fidelity with the legacy data structure. This provides an immediate jump-start to the migration.1
4.2 Handling Polymorphism: The Sample Hierarchy
The legacy system uses JPA Inheritance to model the "Plain" vs. "Detailed" sample distinction. SeaORM does not support inheritance. We must map this using Composition and Enums.
We will define a Sample entity that contains the common fields (ID, Project, Name) and an Enum for the variant data.


Rust




// miso-domain/src/entities/sample.rs
pub struct Sample {
   pub id: i32,
   pub name: String,
   pub details: SampleDetails, // Polymorphic container
}

pub enum SampleDetails {
   Plain(PlainSampleData),
   Detailed(DetailedSampleData),
}

In the database, we can maintain the normalized structure (separate tables). The SeaOrmSampleRepository will be responsible for the "join logic." When loading a sample, it will check the sample_type column and, in a second parallel query, fetch the appropriate details from the child table. This explicit handling of the join avoids the performance penalties often hidden by JPA's inheritance strategies.5
4.3 Solving the N+1 Problem: The Loader Pattern
Hibernate's lazy loading is a primary cause of performance degradation in the legacy system. Rust forces us to be explicit. We will use SeaORM's Loader capabilities to fetch related data efficiently.
The Anti-Pattern (Java/Hibernate approach):


Java




for (Pool pool : pools) {
   // Triggers a SQL query for EVERY pool
   List<Library> libs = pool.getLibraries(); 
}

The Rust Solution (Loader Pattern):


Rust




// Fetches all pools (Query 1)
let pools = Pool::find().all(&db).await?; 
// Fetches all libraries for these pools in ONE batch query (Query 2)
let libraries = pools.load_many(Library, &db).await?; 

This reduces the database load from $O(N)$ to $O(1)$, ensuring that the dashboard loads instantly regardless of the number of samples.6
4.4 Advanced Search and Dynamic Queries
LIMS users require powerful filtering (e.g., "Find all samples created last week by User X that failed QC"). Hibernate uses the Criteria API. SeaORM provides a dynamic query builder.
We will implement a SearchCriteria struct in the Application layer.


Rust




pub struct SampleSearch {
   pub project_id: Option<i32>,
   pub date_range: Option<DateRange>,
   pub qc_status: Option<QcStatus>,
}

The Repository will apply these filters conditionally:


Rust




let mut query = Sample::find();
if let Some(pid) = criteria.project_id {
   query = query.filter(sample::Column::ProjectId.eq(pid));
}
//... apply other filters

This provides the flexibility of a dynamic search with the type safety of Rust.1
________________
5. Hardware Integration: Asynchronous Resilience with Tokio
The ability to interface reliably with laboratory hardware is a critical requirement. The legacy Java implementation uses blocking sockets, which are resource-intensive and prone to hanging. We will use Tokio to build non-blocking, resilient hardware clients.
5.1 The VisionMate Scanner Integration
The VisionMate scanner operates as a TCP server on port 8000. It uses a line-based ASCII protocol.1
* Protocol: Client sends S\r. Scanner responds with OKS,RackID,Well:Barcode,Well:Barcode....
* The Challenge: Network connections in a lab are unstable. Cables get bumped; devices get power-cycled.
The Rust Solution:
We will implement a VisionMateClient actor that manages the TcpStream.
1. Exponential Backoff: The client will not panic on disconnection. It will attempt to reconnect with increasing delays (1s, 2s, 4s...) until successful. This makes the system "self-healing".8
2. Framing with Codecs: We will use tokio_util::codec to implement a VisionMateCodec. This separates the parsing logic (finding the \r delimiter, splitting the CSV) from the I/O logic. It allows us to stream data efficiently without loading the entire response into memory.8
3. Timeouts: Every hardware interaction will be wrapped in tokio::time::timeout. If the scanner doesn't respond in 2 seconds, the future is cancelled, and resources are freed immediately.
5.2 ZPL Label Printing
Label printing is essential. The system must send ZPL (Zebra Programming Language) commands to network printers.
We will use the zpl crate to construct label templates programmatically.


Rust




let label = ZplBuilder::new()
  .text(50, 50, "Sample 123", Font::A, 20)
  .barcode(50, 100, "123456", BarcodeType::Code128)
  .build();

This string is then sent via a raw TcpStream to the printer. This approach prevents syntax errors in the ZPL code that are common when concatenating strings manually in Java.2
________________
6. Frontend Engineering: The Move to Leptos (WASM)
The user interface of MISO is where the scientific efficiency is won or lost. The legacy JSP architecture requires a full page reload for most interactions. We will move to Leptos, a Rust framework that compiles to WebAssembly (WASM), allowing us to run Rust code directly in the browser.
6.1 The Virtualized Plate Map
The core visual component of a LIMS is the Plate Map—a grid representing a 96-well or 384-well plate.
* Performance: In the legacy DOM, rendering 384 individual <div> elements with event listeners can be slow. Leptos uses fine-grained reactivity (Signals). Updating a single well's color (e.g., to indicate "QC Failed") updates only that DOM node, without re-rendering the entire list.
* Virtual Scrolling: For views that show entire freezer racks (containing thousands of samples), we will use Virtualization. The UI will only render the DOM nodes currently visible in the viewport. As the user scrolls, rows are recycled. This allows the UI to handle massive datasets with 60fps smoothness.10
6.2 Drag-and-Drop Workflows
Technicians need to reorganize samples on a plate. This requires intuitive Drag-and-Drop (DnD).
We will use leptos_use or leptos_dnd to wrap the HTML5 Drag and Drop API.
* Optimistic UI: When a user drops a sample into a new well, the local Signal state is updated immediately. The visual feedback is instant.
* Server Functions: Behind the scenes, a #[server] function is called to persist the move. If the server rejects the move (e.g., "Well is occupied"), the UI automatically reverts the change and shows an error. This "Optimistic" approach makes the web app feel like a native desktop application.12
6.3 Server Functions: The RPC Revolution
Leptos allows us to define backend logic directly alongside frontend components using #[server] macros.


Rust




#
pub async fn scan_rack(ip: String) -> Result<Vec<Barcode>, ServerFnError> {
   // This code runs on the Server (Axum)
   // It can call the VisionMateClient directly
   let scanner = VisionMateClient::connect(ip).await?;
   scanner.scan().await
}

When the "Scan" button is clicked in the browser, Leptos handles the serialization, HTTP request, and deserialization automatically. This eliminates the need to write manual REST controllers and DTOs for every single interaction, drastically speeding up development.1
________________
7. Bioinformatics Optimization: Bit-Level Precision
MISO is not just a database; it is a scientific validation engine. A critical requirement is Barcode Collision Detection. When pooling libraries, the system must ensure that the DNA indices (barcodes) are distinct enough to be resolved by the sequencer.
7.1 Hamming Distance Optimization
The requirement is to calculate the Hamming Distance (number of differing positions) between all pairs of barcodes in a pool.
* Legacy: Likely does string comparisons (char by char). This is slow and memory inefficient.
* Rust: We will use Bit-Packing.
   * DNA (A, C, G, T) can be encoded in 2 bits (00, 01, 10, 11).
   * An 8-base index fits into a single u16 integer.
   * The Hamming distance between two bit-packed integers is the population count of their XOR: (a ^ b).count_ones().
   * This is a single CPU instruction. We can perform millions of comparisons per second.
For larger datasets, we can utilize SIMD (Single Instruction, Multiple Data) instructions via the bio crate to compare multiple barcodes in parallel vectors. This ensures that validation, even for complex 384-plex pools, is instantaneous.14
________________
8. Migration Strategy: The Strangler Fig Pattern
We cannot simply turn off the old LIMS and turn on the new one. The risk of data loss or operational disruption is too high. We will employ the Strangler Fig Pattern to migrate the system incrementally.1
Phase 1: The Facade (Weeks 1-4)
* Deploy NGINX in front of the legacy Tomcat server.
* Route all traffic to Legacy. Users see no change.
* This establishes control over the routing layer.
Phase 2: Parallel Read-Only (Weeks 5-8)
* Deploy the Rust miso-api and miso-frontend containers.
* Connect them to the production MySQL DB in Read-Only mode.
* Implement a "Run Status Dashboard" in Rust.
* Configure NGINX to route /dashboard/v2 to the Rust app.
* Goal: Verify that SeaORM maps the legacy schema correctly and that the stack is stable under load.
Phase 3: Vertical Slice - Hardware Scanning (Weeks 9-16)
* Implement the "Rack Scan" workflow in Rust.
* Route /scan traffic to the Rust app.
* The Rust app controls the scanner and writes results to the shared database.
* The Legacy app reads these results from the database.
* Goal: Retire the fragile Java visionmate-client and validate the Write capability of the Rust stack.
Phase 4: Core Domain & Sunset (Months 4-12)
* Systematically migrate complex workflows (Accessioning, Library Prep).
* As each module is migrated, add database triggers to prevent the Legacy app from writing to those tables ("Locking the door behind us").
* Once 100% of functionality is migrated, decommission the Tomcat server.
________________
9. Conclusion
The re-platforming of MISO LIMS to Rust is a definitive step towards the future of high-performance genomics at OICR and Earlham. By replacing the implicit behaviors of the Spring/Hibernate stack with the explicit, type-driven safety of Rust, we eliminate entire classes of bugs and performance bottlenecks. The architecture proposed here—a Modular Monolith leveraging SeaORM, Axum, Tokio, and Leptos—provides a robust, testable, and scalable foundation. It transforms the LIMS from a passive record-keeping tool into a deterministic, high-speed orchestration engine capable of keeping pace with the exponential growth of genomic data. This is not just a software update; it is the establishment of a digital infrastructure that rivals the precision of the biological instruments it serves.
________________
Works Cited
* 1
: Rust Rewrite Research and Planning.txt - User Uploaded Document.
* 1
: Analyzing MISO LIMS GitHub Profile.txt - User Uploaded Document.
* 1
: Research Planning Summaries - Analysis of Architectural Patterns and Tech Stack.
* 1
: Strategic Implementation Directives - Dependency Injection and Architecture.
* 14
: Hamming Distance Implementation and Benchmarks (hamming crate, bio crate).
* 5
: SeaORM Entity Generation, Loader Pattern, and Inheritance Strategies.
* 10
: Leptos Virtual Scrolling, Signals, and Drag-and-Drop implementation.
* 18
: Authorization Implementation with casbin-rs.
* 2
: Zebra Printing and ZPL integration (zebrasend, zpl crates).
* 8
: Tokio TCP Reconnection and Backoff Patterns.
* 3
: Typestate Pattern in Rust.
Works cited
   1. Rust Rewrite Research and Planning.txt
   2. fearful-symmetry/zebrasend: A Rust CLI tool for sending commands to Zebra printers via ZPL and SGD - GitHub, accessed December 15, 2025, https://github.com/fearful-symmetry/zebrasend
   3. Make invalid states unrepresentable : r/rust - Reddit, accessed December 15, 2025, https://www.reddit.com/r/rust/comments/155b6qc/make_invalid_states_unrepresentable/
   4. Make illegal states unrepresentable — but how? The Typestate Pattern in Erlang, accessed December 15, 2025, https://erszcz.medium.com/make-illegal-states-unrepresentable-but-how-the-typestate-pattern-in-erlang-16b37b090d9d
   5. Entity First Workflow | SeaORM An async & dynamic ORM for Rust - SeaQL, accessed December 15, 2025, https://www.sea-ql.org/SeaORM/docs/generate-entity/entity-first/
   6. Tutorial: Modeling Inheritance in SeaORM - SeaQL, accessed December 15, 2025, https://www.sea-ql.org/blog/2025-01-08-sea-orm-inheritance/
   7. SeaORM 2.0: New Entity Format - SeaQL, accessed December 15, 2025, https://www.sea-ql.org/blog/2025-10-20-sea-orm-2.0/
   8. [Resolved ]Help with perpetual tokio tcp stream - The Rust Programming Language Forum, accessed December 15, 2025, https://users.rust-lang.org/t/resolved-help-with-perpetual-tokio-tcp-stream/29072
   9. gistia/zpl - GitHub, accessed December 15, 2025, https://github.com/gistia/zpl
   10. use_infinite_scroll - Leptos-Use Guide, accessed December 15, 2025, https://leptos-use.rs/sensors/use_infinite_scroll.html
   11. React Virtual Scroll - The Candid Startup, accessed December 15, 2025, https://www.thecandidstartup.org/topics/react-virtual-scroll.html
   12. leptos_drag_reorder - Rust - Docs.rs, accessed December 15, 2025, https://docs.rs/leptos_drag_reorder
   13. leptos-use/src/use_draggable.rs at main - GitHub, accessed December 15, 2025, https://github.com/Synphonyte/leptos-use/blob/main/src/use_draggable.rs
   14. hamming::distance - Rust, accessed December 15, 2025, https://huonw.github.io/hamming/hamming/fn.distance.html
   15. hamming in bio::alignment::distance::simd - Rust - Docs.rs, accessed December 15, 2025, https://docs.rs/bio/latest/bio/alignment/distance/simd/fn.hamming.html
   16. distance in hamming - Rust - Docs.rs, accessed December 15, 2025, https://docs.rs/hamming/latest/hamming/fn.distance.html
   17. Full Stack Rust with Leptos - benwis, accessed December 15, 2025, https://benw.is/posts/full-stack-rust-with-leptos
   18. Query to Update Edited New Table - 💬 App Building - Retool Forum, accessed December 15, 2025, https://community.retool.com/t/query-to-update-edited-new-table/26814
   19. Synphonyte/leptos-struct-table: Easily create Leptos table components from structs - GitHub, accessed December 15, 2025, https://github.com/Synphonyte/leptos-struct-table
   20. How to handle reconnect & shutdown correctly in Tokio? - Rust Users Forum, accessed December 15, 2025, https://users.rust-lang.org/t/how-to-handle-reconnect-shutdown-correctly-in-tokio/105759